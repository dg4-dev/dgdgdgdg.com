---
import BaseLayout from '@/layouts/BaseLayout.astro';
import Header from '@/components/header.astro';
import { getNotionData, getNotionBlocksRecursive } from '@/lib/notion';
import Footer from '@/components/footer.astro';
import { Image } from 'astro:assets';

// Notionデータベースからデータを取得
const notionData = await getNotionData();
console.log('=== Works Page: Notion Data ===');
console.log(JSON.stringify(notionData, null, 2));

// すべてのデータを取得（Privateも含めて表示する）
const works = notionData.results;

// Twitterのツイートから画像を取得する関数（SSG対応）
async function getTwitterImageFromUrl(twitterUrl: string): Promise<string | null> {
  try {
    const oembedUrl = `https://publish.twitter.com/oembed?url=${encodeURIComponent(twitterUrl)}&omit_script=true`;

    // タイムアウト設定（10秒）
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 10000);

    try {
      const response = await fetch(oembedUrl, {
        signal: controller.signal,
        headers: {
          'User-Agent': 'Mozilla/5.0 (compatible; dgdgdgdg.com/1.0)',
        },
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        console.warn(`Twitter oEmbed API error for ${twitterUrl}:`, response.status);
        return null;
      }

      const data = await response.json();
      const html = data.html || '';

      // HTMLから画像URLを抽出
      // Twitterの埋め込みHTMLには通常、画像のURLが含まれています
      // パターン1: <img>タグのsrc属性
      const imgMatch = html.match(/<img[^>]+src="([^"]+)"[^>]*>/i);
      if (imgMatch && imgMatch[1]) {
        const imgUrl = imgMatch[1];
        // Twitterの画像URLのパターンをチェック（pbs.twimg.comなど）
        if (imgUrl.includes('pbs.twimg.com') || imgUrl.includes('twimg.com')) {
          return imgUrl;
        }
      }

      // パターン2: data-src属性
      const dataSrcMatch = html.match(/data-src="([^"]+)"/i);
      if (dataSrcMatch && dataSrcMatch[1]) {
        const imgUrl = dataSrcMatch[1];
        if (imgUrl.includes('pbs.twimg.com') || imgUrl.includes('twimg.com')) {
          return imgUrl;
        }
      }

      // パターン3: background-imageのURL
      const bgMatch = html.match(/background-image:\s*url\(['"]?([^'"]+)['"]?\)/i);
      if (bgMatch && bgMatch[1]) {
        const imgUrl = bgMatch[1];
        if (imgUrl.includes('pbs.twimg.com') || imgUrl.includes('twimg.com')) {
          return imgUrl;
        }
      }

      // パターン4: TwitterのメディアURLを直接構築（ツイートIDから）
      try {
        const urlObj = new URL(twitterUrl);
        const pathParts = urlObj.pathname.split('/').filter(Boolean);
        const statusIndex = pathParts.indexOf('status');
        if (statusIndex !== -1 && pathParts[statusIndex + 1]) {
          const tweetId = pathParts[statusIndex + 1];
          // ツイートIDから画像URLを推測（これは確実ではないため、最後の手段）
          // 実際にはoEmbed APIのレスポンスから取得する方が確実
        }
      } catch (e) {
        // URL解析に失敗
      }

      return null;
    } catch (fetchError: any) {
      clearTimeout(timeoutId);
      if (fetchError.name === 'AbortError') {
        console.warn(`Twitter oEmbed API timeout for ${twitterUrl}`);
      } else {
        console.warn(`Error fetching Twitter image for ${twitterUrl}:`, fetchError.message);
      }
      return null;
    }
  } catch (error: any) {
    console.error(`Unexpected error fetching Twitter image for ${twitterUrl}:`, error.message);
    return null;
  }
}

// ブロックからTwitterのURLを検出する関数
function findTwitterUrlInBlocks(blocks: any[]): string | null {
  for (const block of blocks) {
    // embedブロックをチェック
    if (block.type === 'embed' && block.embed?.url) {
      const url = block.embed.url;
      if (url.includes('twitter.com') || url.includes('x.com')) {
        return url;
      }
    }

    // 子ブロックを再帰的にチェック
    if (block.children && block.children.length > 0) {
      const found = findTwitterUrlInBlocks(block.children);
      if (found) return found;
    }
  }
  return null;
}

// 各ワークのカバー画像を取得（Twitterから画像を取得する場合も含む）
// SSGビルド時に実行されるため、エラーハンドリングを強化
const worksWithCoverImages = await Promise.all(
  works.map(async (work: any) => {
    const coverImage = work.properties?.Cover?.files?.[0]?.file?.url ?? '';

    // カバー画像が設定されていない場合、Twitterの画像を取得
    if (!coverImage) {
      try {
        // ブロック取得（SSGビルド時に実行）
        const blocks = await getNotionBlocksRecursive(work.id);
        const twitterUrl = findTwitterUrlInBlocks(blocks);

        if (twitterUrl) {
          console.log(`Found Twitter URL for work ${work.id}: ${twitterUrl}`);
          const twitterImage = await getTwitterImageFromUrl(twitterUrl);
          if (twitterImage) {
            console.log(`Successfully fetched Twitter image for work ${work.id}`);
            // カバー画像として使用
            work.properties = work.properties || {};
            work.properties.Cover = {
              files: [
                {
                  file: {
                    url: twitterImage,
                  },
                },
              ],
            };
          } else {
            console.warn(`Could not fetch Twitter image for work ${work.id}`);
          }
        }
      } catch (error: any) {
        // エラーが発生してもビルドを続行
        console.warn(`Error processing work ${work.id} (continuing build):`, error.message);
      }
    }

    return work;
  }),
);

// 日付を年月のみにフォーマットする関数（表示用）
function formatDateToYearMonth(dateString: string): string {
  if (!dateString) return '';
  // YYYY-MM-DD形式からYYYY-MMに変換
  return dateString.substring(0, 7);
}

// Notionのカテゴリー色をCSSのHEXカラーに変換する関数
function getNotionCategoryColor(colorName: string): string {
  const colorMap: Record<string, string> = {
    default: '#373530',
    gray: '#9B9A97',
    brown: '#64473A',
    red: '#E03E3E',
    orange: '#D9730D',
    yellow: '#DFAB01',
    green: '#0F7B6C',
    blue: '#0B6E99',
    purple: '#6940A5',
    pink: '#AD1A72',
  };
  return colorMap[colorName] || colorMap.default;
}

// 作成日で降順にソート（新しい順）
const sortedWorks = worksWithCoverImages.sort((a: any, b: any) => {
  const dateA = a.properties?.['Created Date']?.date?.start || '';
  const dateB = b.properties?.['Created Date']?.date?.start || '';
  // 日付が空の場合は最後に配置
  if (!dateA && !dateB) return 0;
  if (!dateA) return 1;
  if (!dateB) return -1;
  // 降順（新しい順）
  return dateB.localeCompare(dateA);
});

// 全カテゴリを取得（重複を除去）
const allCategories = new Set<string>();
worksWithCoverImages.forEach((work: any) => {
  const categories = work.properties?.Category?.multi_select ?? [];
  categories.forEach((cat: any) => {
    if (cat.name) {
      allCategories.add(cat.name);
    }
  });
});
const uniqueCategories = Array.from(allCategories).sort();
---

<BaseLayout title="Works - dgdgdgdg" description="制作実績の一覧" keywords="works, portfolio, projects">
  <Fragment slot="head"> </Fragment>
  <Header />
  <main>
    <!-- Works data for client-side filtering/sorting -->
    <script define:vars={{ worksData: works, categoriesData: uniqueCategories }}>
      window.__WORKS_DATA__ = worksData;
      window.__CATEGORIES_DATA__ = categoriesData;
    </script>
    <div class="works-grid" id="works-grid">
      {
        sortedWorks.map((item: any) => {
          const title = item.properties?.Title?.title?.[0]?.plain_text ?? 'No title';
          const client = item.properties?.Client?.rich_text?.[0]?.plain_text ?? '';
          const createdDateFull = item.properties?.['Created Date']?.date?.start ?? '';
          const createdDate = formatDateToYearMonth(createdDateFull); // 表示用は年月のみ
          const categories = item.properties?.Category?.multi_select ?? [];
          const coverImage = item.properties?.Cover?.files?.[0]?.file?.url ?? '';
          const workId = item.properties?.id?.rich_text?.[0]?.plain_text ?? item.id;
          const isPrivate = item.properties?.Private?.checkbox;

          const cardInner = (
            <>
              {isPrivate ? (
                <div class="work-cover">
                  <Image
                    src="/images/private-sample.png"
                    alt="Private work sample"
                    width={520}
                    height={360}
                    loading="lazy"
                  />
                </div>
              ) : (
                coverImage && (
                  <div class="work-cover">
                    <Image src={coverImage} alt={title} width={520} height={360} loading="lazy" />
                  </div>
                )
              )}
              <div class="work-content">
                <h2>{title}</h2>
                {isPrivate ? (
                  <p class="work-client">プライベート</p>
                ) : (
                  client && <p class="work-client">Client: {client}</p>
                )}
                {createdDate && <p class="work-date">{createdDate}</p>}
                {categories.length > 0 && (
                  <div class="work-categories">
                    {categories.map((cat: any) => (
                      <span class="category-tag" style={`background-color: ${getNotionCategoryColor(cat.color)}`}>
                        {cat.name}
                      </span>
                    ))}
                  </div>
                )}
              </div>
            </>
          );

          const categoryNames = categories.map((cat: any) => cat.name).join(',');

          return isPrivate ? (
            <article
              class="work-card"
              data-work-title={title}
              data-work-date={createdDateFull || ''}
              data-work-private="true"
              data-work-categories={categoryNames}
            >
              {cardInner}
            </article>
          ) : (
            <a
              href={`/works/${workId}`}
              class="work-card work-card--link"
              data-work-title={title}
              data-work-date={createdDateFull || ''}
              data-work-private="false"
              data-work-categories={categoryNames}
            >
              {cardInner}
            </a>
          );
        })
      }
    </div>
  </main>
  <Footer />
</BaseLayout>

<style lang="sass">
  main
    margin: 0
    padding: 0

  .works-grid
    width: 100%
    max-width: 1200px
    margin: 0 auto
    padding: 120px 40px
    display: grid
    grid-template-columns: repeat(auto-fill, minmax(260px, 1fr))
    gap: 24px

  .work-card
    border: 1px solid #e0e0e0
    border-radius: 12px
    overflow: hidden
    background-color: #ffffff
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.04)
    transition: transform 0.2s ease, box-shadow 0.2s ease

    &:hover
      transform: translateY(-4px)
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.08)

  .work-card--link
    text-decoration: none
    color: inherit
    display: block

  .work-cover
    width: 100%
    height: 180px
    overflow: hidden

    img
      width: 100%
      height: 100%
      object-fit: cover

  .work-content
    padding: 16px 20px 20px

    h2
      margin: 0 0 8px 0
      font-size: 20px
      color: #111111

    .work-client
      color: #777777
      font-size: 14px
      margin: 2px 0

    .work-date
      color: #999999
      font-size: 12px
      margin-top: 4px

    .work-categories
      display: flex
      flex-wrap: wrap
      gap: 6px
      margin-top: 10px

      .category-tag
        padding: 2px 6px 4px 6px
        border-radius: 4px
        font-size: 16px
        font-family: 'Zen Kaku Gothic New', sans-serif
        font-weight: 700
        color: #ffffff
        opacity: 0.9

  details
    margin-top: 3rem

    summary
      cursor: pointer
      padding: 0.5rem
      background: #f5f5f5
      border-radius: 4px

    pre
      margin-top: 1rem
      padding: 1rem
      background: #f5f5f5
      border-radius: 4px
      overflow-x: auto
      font-size: 0.85rem
</style>

<script is:inline>
  (function () {
    var sortHandler = null;
    var filterHandler = null;

    function updateWorks(sortSelect, filterSelect, categorySelect, worksGrid) {
      var sortValue = sortSelect.value;
      var filterValue = filterSelect.value;
      var categoryValue = categorySelect.value;
      var cards = Array.from(worksGrid.querySelectorAll('.work-card'));

      // フィルタリング（表示/非表示を判定）
      var visibleCards = [];
      var hiddenCards = [];

      cards.forEach(function (card) {
        var isPrivate = card.getAttribute('data-work-private') === 'true';
        var categories = card.getAttribute('data-work-categories') || '';
        var categoryList = categories
          ? categories.split(',').map(function (c) {
              return c.trim();
            })
          : [];

        // 公開/プライベートフィルター
        var shouldShow = false;
        if (filterValue === 'public') {
          shouldShow = !isPrivate;
        } else if (filterValue === 'private') {
          shouldShow = isPrivate;
        } else {
          shouldShow = true; // 'all'
        }

        // カテゴリフィルター
        if (shouldShow && categoryValue !== 'all') {
          shouldShow = categoryList.includes(categoryValue);
        }

        if (shouldShow) {
          card.style.display = '';
          visibleCards.push(card);
        } else {
          card.style.display = 'none';
          hiddenCards.push(card);
        }
      });

      // 表示されているカードをソート
      visibleCards.sort(function (a, b) {
        if (sortValue === 'date_desc') {
          var dateA = a.getAttribute('data-work-date') || '';
          var dateB = b.getAttribute('data-work-date') || '';
          return dateB.localeCompare(dateA);
        } else if (sortValue === 'date_asc') {
          var dateA = a.getAttribute('data-work-date') || '';
          var dateB = b.getAttribute('data-work-date') || '';
          return dateA.localeCompare(dateB);
        }
        return 0;
      });

      // DOMの順序を更新（表示カードをソート順に、その後非表示カードを追加）
      visibleCards.forEach(function (card) {
        worksGrid.appendChild(card);
      });
      hiddenCards.forEach(function (card) {
        worksGrid.appendChild(card);
      });
    }

    function initWorksSortAndFilter() {
      var sortSelect = document.querySelector('[data-works-sort]');
      var filterSelect = document.querySelector('[data-works-filter]');
      var categorySelect = document.querySelector('[data-works-category]');
      var worksGridElement = document.getElementById('works-grid');

      if (!sortSelect || !filterSelect || !categorySelect || !worksGridElement) {
        // 要素が見つからない場合は少し待って再試行
        setTimeout(initWorksSortAndFilter, 100);
        return;
      }

      var worksGrid = worksGridElement;

      // 既存のイベントリスナーを削除
      if (sortHandler) {
        sortSelect.removeEventListener('change', sortHandler);
      }
      if (filterHandler) {
        filterSelect.removeEventListener('change', filterHandler);
      }

      // 新しいイベントハンドラーを作成
      var updateHandler = function () {
        updateWorks(sortSelect, filterSelect, categorySelect, worksGrid);
      };
      sortHandler = updateHandler;
      filterHandler = updateHandler;

      // イベントリスナーを追加
      sortSelect.addEventListener('change', sortHandler);
      filterSelect.addEventListener('change', filterHandler);
      categorySelect.addEventListener('change', updateHandler);
    }

    // 初期化関数
    function init() {
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function () {
          initWorksSortAndFilter();
          // 初期表示時にソートを実行
          setTimeout(function () {
            var sortSelect = document.querySelector('[data-works-sort]');
            var filterSelect = document.querySelector('[data-works-filter]');
            var categorySelect = document.querySelector('[data-works-category]');
            var worksGridElement = document.getElementById('works-grid');
            if (sortSelect && filterSelect && categorySelect && worksGridElement) {
              updateWorks(sortSelect, filterSelect, categorySelect, worksGridElement);
            }
          }, 100);
        });
      } else {
        // DOMが既に読み込まれている場合は少し待ってから実行
        setTimeout(function () {
          initWorksSortAndFilter();
          // 初期表示時にソートを実行
          setTimeout(function () {
            var sortSelect = document.querySelector('[data-works-sort]');
            var filterSelect = document.querySelector('[data-works-filter]');
            var categorySelect = document.querySelector('[data-works-category]');
            var worksGridElement = document.getElementById('works-grid');
            if (sortSelect && filterSelect && categorySelect && worksGridElement) {
              updateWorks(sortSelect, filterSelect, categorySelect, worksGridElement);
            }
          }, 100);
        }, 0);
      }
    }

    // 初期化実行
    init();

    // Astro View Transitions対応
    document.addEventListener('astro:after-swap', function () {
      sortHandler = null;
      filterHandler = null;
      setTimeout(initWorksSortAndFilter, 0);
    });
  })();
</script>
