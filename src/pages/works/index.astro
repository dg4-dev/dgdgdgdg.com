---
export const prerender = true;

import BaseLayout from '@/layouts/BaseLayout.astro';
import Header from '@/components/header.astro';
import { getNotionData, getNotionBlocksRecursive } from '@/lib/notion';
import Footer from '@/components/footer.astro';
import ContactCTA from '@/components/ContactCTA.astro';
import WorkCard from '@/components/WorkCard.astro';

// Notionデータベースからデータを取得
const notionData = await getNotionData();

// すべてのデータを取得（Privateも含めて表示する）
const works = notionData.results;

// Twitterのツイートから画像を取得する関数（SSG対応）
async function getTwitterImageFromUrl(twitterUrl: string): Promise<string | null> {
  try {
    const oembedUrl = `https://publish.twitter.com/oembed?url=${encodeURIComponent(twitterUrl)}&omit_script=true`;

    // タイムアウト設定（10秒）
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 10000);

    try {
      const response = await fetch(oembedUrl, {
        signal: controller.signal,
        headers: {
          'User-Agent': 'Mozilla/5.0 (compatible; dgdgdgdg.com/1.0)',
        },
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        return null;
      }

      const data = await response.json();
      const html = data.html || '';

      // HTMLから画像URLを抽出
      // Twitterの埋め込みHTMLには通常、画像のURLが含まれています
      // パターン1: <img>タグのsrc属性
      const imgMatch = html.match(/<img[^>]+src="([^"]+)"[^>]*>/i);
      if (imgMatch && imgMatch[1]) {
        const imgUrl = imgMatch[1];
        // Twitterの画像URLのパターンをチェック（pbs.twimg.comなど）
        if (imgUrl.includes('pbs.twimg.com') || imgUrl.includes('twimg.com')) {
          return imgUrl;
        }
      }

      // パターン2: data-src属性
      const dataSrcMatch = html.match(/data-src="([^"]+)"/i);
      if (dataSrcMatch && dataSrcMatch[1]) {
        const imgUrl = dataSrcMatch[1];
        if (imgUrl.includes('pbs.twimg.com') || imgUrl.includes('twimg.com')) {
          return imgUrl;
        }
      }

      // パターン3: background-imageのURL
      const bgMatch = html.match(/background-image:\s*url\(['"]?([^'"]+)['"]?\)/i);
      if (bgMatch && bgMatch[1]) {
        const imgUrl = bgMatch[1];
        if (imgUrl.includes('pbs.twimg.com') || imgUrl.includes('twimg.com')) {
          return imgUrl;
        }
      }

      // パターン4: TwitterのメディアURLを直接構築（ツイートIDから）
      try {
        const urlObj = new URL(twitterUrl);
        const pathParts = urlObj.pathname.split('/').filter(Boolean);
        const statusIndex = pathParts.indexOf('status');
        if (statusIndex !== -1 && pathParts[statusIndex + 1]) {
          const tweetId = pathParts[statusIndex + 1];
          // ツイートIDから画像URLを推測（これは確実ではないため、最後の手段）
          // 実際にはoEmbed APIのレスポンスから取得する方が確実
        }
      } catch (e) {
        // URL解析に失敗
      }

      return null;
    } catch (fetchError: any) {
      clearTimeout(timeoutId);
      return null;
    }
  } catch {
    return null;
  }
}

// ブロックからTwitterのURLを検出する関数
function findTwitterUrlInBlocks(blocks: any[]): string | null {
  for (const block of blocks) {
    // embedブロックをチェック
    if (block.type === 'embed' && block.embed?.url) {
      const url = block.embed.url;
      if (url.includes('twitter.com') || url.includes('x.com')) {
        return url;
      }
    }

    // 子ブロックを再帰的にチェック
    if (block.children && block.children.length > 0) {
      const found = findTwitterUrlInBlocks(block.children);
      if (found) return found;
    }
  }
  return null;
}

// 各ワークのカバー画像を取得（Twitterから画像を取得する場合も含む）
// SSGビルド時に実行されるため、エラーハンドリングを強化
const worksWithCoverImages = await Promise.all(
  works.map(async (work: any) => {
    const coverImage = work.properties?.Cover?.files?.[0]?.file?.url ?? '';

    // カバー画像が設定されていない場合、Twitterの画像を取得
    if (!coverImage) {
      try {
        // ブロック取得（SSGビルド時に実行）
        const blocks = await getNotionBlocksRecursive(work.id);
        const twitterUrl = findTwitterUrlInBlocks(blocks);

        if (twitterUrl) {
          const twitterImage = await getTwitterImageFromUrl(twitterUrl);
          if (twitterImage) {
            // カバー画像として使用
            work.properties = work.properties || {};
            work.properties.Cover = {
              files: [
                {
                  file: {
                    url: twitterImage,
                  },
                },
              ],
            };
          }
        }
      } catch {
        // エラーが発生してもビルドを続行
      }
    }

    return work;
  }),
);

// 日付を年月のみにフォーマットする関数（表示用）
function formatDateToYearMonth(dateString: string): string {
  if (!dateString) return '';
  // YYYY-MM-DD形式からYYYY-MMに変換
  return dateString.substring(0, 7);
}

// 作成日で降順にソート（新しい順）
const sortedWorks = worksWithCoverImages.sort((a: any, b: any) => {
  const dateA = a.properties?.['Created Date']?.date?.start || '';
  const dateB = b.properties?.['Created Date']?.date?.start || '';
  // 日付が空の場合は最後に配置
  if (!dateA && !dateB) return 0;
  if (!dateA) return 1;
  if (!dateB) return -1;
  // 降順（新しい順）
  return dateB.localeCompare(dateA);
});

// 全カテゴリを取得（重複を除去）
const allCategories = new Set<string>();
worksWithCoverImages.forEach((work: any) => {
  const categories = work.properties?.Category?.multi_select ?? [];
  categories.forEach((cat: any) => {
    if (cat.name) {
      allCategories.add(cat.name);
    }
  });
});
const uniqueCategories = Array.from(allCategories).sort();
---

<BaseLayout title="Works - dgdgdgdg" description="制作実績の一覧" keywords="works, portfolio, projects">
  <Fragment slot="head"> </Fragment>
  <Header />
  <main>
    <!-- Works data for client-side filtering/sorting -->
    <script define:vars={{ worksData: works, categoriesData: uniqueCategories }}>
      window.__WORKS_DATA__ = worksData;
      window.__CATEGORIES_DATA__ = categoriesData;
    </script>
    <div class="works-grid" id="works-grid">
      {
        sortedWorks.map((item: any) => {
          const title = item.properties?.Title?.title?.[0]?.plain_text ?? 'No title';
          const client = item.properties?.Client?.rich_text?.[0]?.plain_text ?? '';
          const createdDateFull = item.properties?.['Created Date']?.date?.start ?? '';
          const createdDate = formatDateToYearMonth(createdDateFull);
          const categories = item.properties?.Category?.multi_select ?? [];
          const coverImage = item.properties?.Cover?.files?.[0]?.file?.url ?? '';
          const workId = item.properties?.id?.rich_text?.[0]?.plain_text ?? item.id;
          const isPrivate = item.properties?.Private?.checkbox ?? false;
          const categoryNames = categories.map((cat: any) => cat.name).join(',');

          return (
            <WorkCard
              title={title}
              client={client}
              createdDate={createdDate}
              categories={categories}
              coverImageUrl={coverImage}
              workId={workId}
              isPrivate={isPrivate}
              href={isPrivate ? undefined : `/works/article/${workId}`}
              dataWorkTitle={title}
              dataWorkDate={createdDateFull || ''}
              dataWorkCategories={categoryNames}
            />
          );
        })
      }
    </div>
  </main>
  <ContactCTA />
  <Footer />
</BaseLayout>

<style lang="sass">
  main
    margin: 0
    padding: 0

  .works-grid
    width: 100%
    max-width: 1200px
    margin: 0 auto
    padding: 120px 40px
    display: grid
    grid-template-columns: repeat(auto-fill, minmax(260px, 1fr))
    gap: 40px 24px
    align-items: end

  @media (max-width: 768px)
    .works-grid
      padding-top: 190px
      grid-template-columns: repeat(2, 1fr)
      padding-left: 16px
      padding-right: 16px
      gap: 24px 12px

  details
    margin-top: 3rem

    summary
      cursor: pointer
      padding: 0.5rem
      background: var(--c-gray-100)
      border-radius: 4px

    pre
      margin-top: 1rem
      padding: 1rem
      background: var(--c-gray-100)
      border-radius: 4px
      overflow-x: auto
      font-size: 0.85rem
</style>

<script is:inline>
  (function () {
    var sortHandler = null;
    var filterHandler = null;

    function updateWorks(sortSelect, filterSelect, categorySelect, worksGrid) {
      var sortValue = sortSelect.value;
      var filterValue = filterSelect.value;
      var categoryValue = categorySelect.value;
      var cards = Array.from(worksGrid.querySelectorAll('.work-card'));

      // フィルタリング（表示/非表示を判定）
      var visibleCards = [];
      var hiddenCards = [];

      cards.forEach(function (card) {
        var isPrivate = card.getAttribute('data-work-private') === 'true';
        var categories = card.getAttribute('data-work-categories') || '';
        var categoryList = categories
          ? categories.split(',').map(function (c) {
              return c.trim();
            })
          : [];

        // 公開/プライベートフィルター
        var shouldShow = false;
        if (filterValue === 'public') {
          shouldShow = !isPrivate;
        } else if (filterValue === 'private') {
          shouldShow = isPrivate;
        } else {
          shouldShow = true; // 'all'
        }

        // カテゴリフィルター
        if (shouldShow && categoryValue !== 'all') {
          shouldShow = categoryList.includes(categoryValue);
        }

        if (shouldShow) {
          card.style.display = '';
          visibleCards.push(card);
        } else {
          card.style.display = 'none';
          hiddenCards.push(card);
        }
      });

      // 表示されているカードをソート
      visibleCards.sort(function (a, b) {
        if (sortValue === 'date_desc') {
          var dateA = a.getAttribute('data-work-date') || '';
          var dateB = b.getAttribute('data-work-date') || '';
          return dateB.localeCompare(dateA);
        } else if (sortValue === 'date_asc') {
          var dateA = a.getAttribute('data-work-date') || '';
          var dateB = b.getAttribute('data-work-date') || '';
          return dateA.localeCompare(dateB);
        }
        return 0;
      });

      // DOMの順序を更新（表示カードをソート順に、その後非表示カードを追加）
      visibleCards.forEach(function (card) {
        worksGrid.appendChild(card);
      });
      hiddenCards.forEach(function (card) {
        worksGrid.appendChild(card);
      });
    }

    function initWorksSortAndFilter() {
      var sortSelect = document.querySelector('[data-works-sort]');
      var filterSelect = document.querySelector('[data-works-filter]');
      var categorySelect = document.querySelector('[data-works-category]');
      var worksGridElement = document.getElementById('works-grid');

      if (!sortSelect || !filterSelect || !categorySelect || !worksGridElement) {
        // 要素が見つからない場合は少し待って再試行
        setTimeout(initWorksSortAndFilter, 100);
        return;
      }

      var worksGrid = worksGridElement;

      // 既存のイベントリスナーを削除
      if (sortHandler) {
        sortSelect.removeEventListener('change', sortHandler);
      }
      if (filterHandler) {
        filterSelect.removeEventListener('change', filterHandler);
      }

      // 新しいイベントハンドラーを作成
      var updateHandler = function () {
        updateWorks(sortSelect, filterSelect, categorySelect, worksGrid);
      };
      sortHandler = updateHandler;
      filterHandler = updateHandler;

      // イベントリスナーを追加
      sortSelect.addEventListener('change', sortHandler);
      filterSelect.addEventListener('change', filterHandler);
      categorySelect.addEventListener('change', updateHandler);
    }

    // 初期化関数
    function init() {
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function () {
          initWorksSortAndFilter();
          // 初期表示時にソートを実行
          setTimeout(function () {
            var sortSelect = document.querySelector('[data-works-sort]');
            var filterSelect = document.querySelector('[data-works-filter]');
            var categorySelect = document.querySelector('[data-works-category]');
            var worksGridElement = document.getElementById('works-grid');
            if (sortSelect && filterSelect && categorySelect && worksGridElement) {
              updateWorks(sortSelect, filterSelect, categorySelect, worksGridElement);
            }
          }, 100);
        });
      } else {
        // DOMが既に読み込まれている場合は少し待ってから実行
        setTimeout(function () {
          initWorksSortAndFilter();
          // 初期表示時にソートを実行
          setTimeout(function () {
            var sortSelect = document.querySelector('[data-works-sort]');
            var filterSelect = document.querySelector('[data-works-filter]');
            var categorySelect = document.querySelector('[data-works-category]');
            var worksGridElement = document.getElementById('works-grid');
            if (sortSelect && filterSelect && categorySelect && worksGridElement) {
              updateWorks(sortSelect, filterSelect, categorySelect, worksGridElement);
            }
          }, 100);
        }, 0);
      }
    }

    // 初期化実行
    init();

    // Astro View Transitions対応
    document.addEventListener('astro:after-swap', function () {
      sortHandler = null;
      filterHandler = null;
      setTimeout(initWorksSortAndFilter, 0);
    });
  })();
</script>
